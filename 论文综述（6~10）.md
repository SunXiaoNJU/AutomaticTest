# 论文综述（6~10）

## 6. **Astrée: from Research to Industry**

（本文主要结合关键词analysis、alarms进行查找翻译以及分析，主要是对文章中的关键信息进行提取，详细的分析等所有文章都提取后再开展）

### 6.0 基本信息

David Delmas and Jean Souyris. "Astrée: from research to industry." *International Static Analysis Symposium*. Springer, Berlin, Heidelberg, 2007.

### 6.1 概念

1. Astrée 就是这样一个静态分析器：当它试图证明用 C 编写的控制/命令程序中不存在运行时错误时，它只会产生少量的错误警报，并为用户提供足够的选项和指令以 帮助将这个数字减少到零。
2. 通过对 Astrée 对工业项目进行的分析的描述，我们从工程的角度概述了减少误报的过程，并为静态分析仪的新兴市场勾勒了一个可能的客户-供应商关系模型。

### 6.2 问题与现状

1. 无论任何此类工具多么精确，在实际大小的工业软件上首次运行它通常会产生至少一些错误警报。出于安全和工业原因，此错误警报的数量应尽可能少，并且工程用户应该能够通过新的微调分析将其减少到零。事实上，产生的误报越少，所需的成本、耗时和容易出错的补充智力分析就越少。
2. 我们不使用 Astrée 来搜索可能的运行时错误； 我们使用它来证明永远不会发生运行时错误。 因此，必须调查每一个警报。 此外，每次 Astrée 发出警报时，它假定只要满足警报的先决条件，分析程序的执行就会停止，因为在发生错误时程序行为是未定义的。例如，越界数组赋值可能会破坏代码。 因此，任何可满足的警报条件都可能“隐藏”更多警报。
3. 这就是为什么需要进行详尽的警报分析的原因：每个错误警报都应该通过更精确的自动分析来消失，或者，如果做不到这一点，则由用户证明在程序的真实环境中是不可能的。

### 6.3 解决方案

1. 每条警报消息都指向预处理代码中的一个程序位置。回到相应的源代码以获得可读的上下文信息通常很有用。考虑到警报指向的操作所处理的每个全局变量，可以提取相应的区间，这是对该变量范围的合理过度逼近。
2. 我们必须在程序数据流中倒退，以便找到警报的根源：错误或自动分析的精度不足。此活动可能非常耗时。
3. 工程用户确实可以用间隔标记代表全局变量的每个箭头，从警报位置向后移动。当检测到变量范围突然莫名增加时，通常会发现问题的根源。
4. 我们知道警报是源自某些效果有限的本地代码还是源自某些特定的专用运算符（即函数或宏函数）。 实际上，一种有效的方法是首先关注程序中经常使用的运算符中的警报，特别是如果具有不同堆栈上下文的多个警报指向相同的运算符：此类警报通常会影响调用函数的分析，因此发出更多警报。 对于具有相当线性调用图的控制/命令程序，首先选择源自数据流早期的警报也是非常有利可图的。 消除此类警报可能有助于消除稍后在数据流中产生的其他警报。
5. 在完整程序上引发的每个警报通常也会在简化示例上引发。 此外，使用简化示例进行实验要容易得多。一旦在简化示例上找到了令人满意的解决方案，它就会重新注入到整个程序的分析中：在大多数情况下，警报的数量会减少。

### 6.4 结论

1. 客户必须透露有关目标程序的结构、执行模型、维度和执行的计算类型的详细信息，并提供具有代表性的示例。
2. 工具的提供者必须准备好更新他们的产品，例如添加或改进抽象域，只要参数集不再足以精确分析族中的某些程序，即使在执行了工具专业化之后也是如此。



## 7. Automated Identifification of Actionable Static Code Analysis Alerts on Open Source Systems: Fiware as an Example

### 7.0 基本信息

MİNTEMUR, Ömer, et al. "Automated Identification of Actionable Static Code Analysis Alerts on Open Source Systems: Fiware as an Example."

### 7.1 问题与现状

1. 尽管静态分析工具很常见，但它们识别的反模式经常被开发人员忽略，因为静态分析工具可能会产生很高的误报率，这可能非常耗时。考虑到生产力损失，研究人员一直在尝试区分可操作（必须修复）和不可操作（可能未修复，没有足够严重的问题来修复）警报。
2. 自动软件分析（ASA）工具已广泛用于软件世界，以通过错误等方式控制软件的流程。尽管使用 ASA 程序有很多好处，但它们通常会为单个软件实例生成大量警报。自然，随着警报数量的增加，开发人员纠正所有这些警报的挑战变得更加困难。

### 7.2 实验

![image-20221005170155379](%E8%AE%BA%E6%96%87%E7%BB%BC%E8%BF%B0%EF%BC%886~10%EF%BC%89.assets/image-20221005170155379.png)

研究结果表明，已采取措施的错误中有 80% 的优先级为 3。其他分别为 5、2 和 1。在已解决的所有错误中，最常见的错误是 DataflowAnomalyAnalysis，它属于 Error Prone 规则集。

### 7.3 解决方案

1. 使用 PMD 作为静态软件分析工具来分析软件，并假设后期版本中修复的反模式是可操作的。
2.  Ruthruff et. al.从谷歌收集了样本警告数据，并提出了一种机器学习方法，该方法使用逻辑回归来预测 FindBugs 警告是可操作的警告还是琐碎（不可操作）的警告。
3. 对于两个连续的版本，我们比较了每个函数中的所有错误。 如果在字母版本中没有以相同的方法检测到相同优先级的错误和规则，则认为错误已经解决，这表明它是可操作的。 其余错误被假定为不可操作。

### 7.4 结论

1. 如果警报在软件的修订历史记录中关闭，则警报是可操作的。 
2. 如果警报因文件删除而关闭，则警报既不可操作也不不可操作，并从警报集中删除。
3. 其他警报可以通过检查进行分类，也可以标记为不可操作。
4. 这项工作存在一些局限性，这可能会使我们的结果难以概括。主要限制是标记不可操作的警报。
5. 将来，我们计划为每种类型的错误分配一个等待时间，然后再将其标记为不可操作，以放宽这种过于简单的假设。我们还想分析警报之间邻域的影响，并调查解决出现在同一文件中的不可操作警报的可能趋势，或与高优先级可操作警报一起工作。通过观察由于其可操作的邻居而由开发人员解决的不可操作的警报，可以处理许多值得信赖的数据集并获得更稳定的结果。



## 8. **Boosting Static Analysis Accuracy with Instrumented Test** Executions

### 8.0 基本信息

Chen, Tianyi, Kihong Heo, and Mukund Raghothaman. "Boosting static analysis accuracy with instrumented test executions." *Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering*. 2021.

### 8.1 概念

1. 在本文中，我们介绍了 DynaBoost，该系统使用从测试执行中获得的信息来对静态分析仪的警报进行优先级排序。
2. 我们检测程序以动态查找静态分析器预测的数据流行为，并使用这些结果来引导概率警报排名系统，在该系统中，用户反复检查被判断为最有可能是真正错误的警报，并且系统重新根据用户反馈对剩余警报进行排名。

### 8.2 问题与现状

1. 组合系统能够利用用户无法轻易提供的信息，并显着改善人工警报检查负担：与基线排名系统相比，减少了 35%，与独立程序员分类警报报告相比，减少了 89%。
2. 一方面，静态分析提供了详尽的验证，但会发出许多错误警告，尤其是在分析大段代码时。
3. 另一方面，动态分析工具具有更高的精度——仪表框架如 Valgrind、内存安全检查器如 AddressSanitizer 和 MemorySanitizer，以及数据竞争检测器如 ThreadSanitizer和 RoadRunner已经在大型开源项目中发现了数百个错误和安全漏洞，但由于测试套件导致的低覆盖率，经常会漏掉错误。
4. 这自然提出了一个问题：我们是否可以使用从见证程序执行中收集的经验数据来提高静态分析工具的有效准确性？
5. 首先，贝叶斯网络的纯静态初始化信息有限，需要更多的人工指导。 这在错误泛化的情况下很明显：由于抽象必然过度近似程序行为，从程序的抽象行为派生的概率模型有时会导致用户给出的负面反馈错误地传播到真正的错误，从而抑制它们。 此外，用户通常只能回答有关最终警告的正确性的问题，而不能回答有关分析得出的中间断言和数据流事实的问题，最后，错误的人为反馈可能会大大降低后续迭代中的排名质量 .

### 8.3 解决方案

1. 我们使用 Sparrow 程序分析器。它使用稀疏分析框架计算的 def-use 图来确定导致敏感内存访问的所有数据依赖关系，然后执行区间分析以证明内存安全。正如人们所预料的那样，它无法证明在第 38 行调用 memmove 的安全性，并在该行发出警报。 

2. 重构推导图。第一步是重建导致 Sparrow 报告每个警报的推理轨迹。这个推理过程——应用于 def-use 图的区间分析——可以用图 3 所示的推导规则来近似描述。从程序中的变量定义和一步数据流边开始，由 VarDefn(𝑎 ) 和 DUEdge(𝑎, 𝑏)，分析器计算 DUPath(𝑎, 𝑏) 形式的数据流路径。如果每个派生的 DUPath(𝑎, 𝑏) 中的最后一个节点 𝑏 对应于一个数组访问，则分析器执行额外的推理来证明程序点 𝑏 处操作的安全性。请注意，我们没有对这个子分析的细节进行建模——它采用了区间抽象——而是提供了溢出（𝑏）形式的输入元组作为推理过程中未建模部分的存根。当分析器发现导致潜在不安全内存访问的此类数据流路径时，它会在适当的点报告警报，如推导规则 𝑟3 所示。

   ![image-20221006103438690](%E8%AE%BA%E6%96%87%E7%BB%BC%E8%BF%B0%EF%BC%886~10%EF%BC%89.assets/image-20221006103438690.png)

3. 我们在警报排名系统的概率框架中结合了静态和动态分析，例如通过插入动态检查来验证无法静态证明的属性，使用从测试执行中收集的信息来为后续分析运行优化设置旋钮，通过代码片段来指导测试的 concolic 执行难以探索的，使用静态分析来最小化动态监控的数量，或有限的穷举测试。

4. 不了解分析设计细节的静态分析器的人类用户只能提供有限形式的反馈，例如警报标签。DynaBoost 通过结合来自测试用例的动态分析结果克服了这一限制，从而提高了警报排名系统的性能。

### 8.4 结论

在本文中，我们开发了一种概率技术来利用动态分析的结果来提高静态分析器的有效精度。 通过程序的针对性检测，我们能够通过实验确认静态分析器得出的中间结论的存在，并使用此反馈来确定生成警报的优先级。 在实验中，我们证明了人工警报检查负担的显着减少，以及其他相关指标的改进，例如初始排名的质量和错误的泛化事件。 我们预计这项研究在综合测试用例和自动故障定位方面的潜在应用。



## 9. Detecting and Removing Web Application Vulnerabilities with Static Analysis and Data Mining

### 9.0 基本信息

Medeiros, Ibéria, Nuno Neves, and Miguel Correia. "Detecting and removing web application vulnerabilities with static analysis and data mining." *IEEE Transactions on Reliability* 65.1 (2015): 54-69.

### 9.1 问题与现状

1. 尽管对 Web 应用程序安全性的大量研究工作已经进行了十多年，但 Web 应用程序的安全性仍然是一个具有挑战性的问题。
2. 源代码静态分析工具是一种发现漏洞的解决方案，但它们往往会产生误报，并且需要程序员手动修复代码付出相当大的努力。
3. 用于漏洞检测的污点分析已经研究了十多年。但是，该领域的论文没有详细介绍该过程，并且通常不会进行跨过程、全局和上下文相关的分析。

### 9.2 解决方案

1. 我们探索使用一种新的方法组合来检测这种类型的漏洞：静态分析和数据挖掘。我们补充了一种静态分析形式，即污点分析，使用数据挖掘来预测误报的存在。 该解决方案结合了两种明显不相交的方法：人类对有关漏洞的知识进行编码（用于污点分析），以及自动获取该知识（通过有监督的机器学习支持数据挖掘）。

2. 我们介绍了我们是如何做到的。污点分析器是一个静态分析工具，它在由词法分析器和解析器创建的 AST 上运行，在我们的例子中是 PHP 5（在 WAP 中，我们使用 ANTLR 实现了它）。在分析开始时，所有符号（变量、函数）都是未污染的，除非它们是入口点。tree walkers（也使用 ANTLR 实现）构建了一个污染符号表 (TST)，其中每个单元格都是一个程序语句，我们要收集数据（见图 4）。每个单元格包含 AST 的一个子树以及一些数据。例如，for 语句 $x = $b + $c； TST 单元包含 AST 的子树，表示$x对$b和$c的依赖。对于每个符号，存储了几个数据项，例如符号名称、语句的行号和污染度。

   ![image-20221006192937885](%E8%AE%BA%E6%96%87%E7%BB%BC%E8%BF%B0%EF%BC%886~10%EF%BC%89.assets/image-20221006192937885.png)

3. 污点分析模型具有以下步骤：

   1) 通过从 AST 收集数据来创建 TST，并将入口点标记为受污染。
   2) 如果传播其污点的变量属于 TEPT 而不是 UD，则通过将变量设置为 TST 中的污点来传播污点。
   3) 通过在 UD 中插入属于 TEPT 并在 TST 中清理过的任何污染变量来阻止污染传播； 相反，如果变量被污染，则从 UD 中删除它。
   4) 创建 TEPT： (i) 为每个由 TST 产生的新污染变量创建一个新分支； (ii) 为变量被污染的每一行代码创建一个子分支； (iii) 子分支中的条目是用一个变量创建的，该变量被分支变量的污染传播所污染。
   5) 每当代表敏感接收器的 TST 单元在与步骤 2 相同的条件下被污染变量到达时，标记漏洞。

4. 在分析过程中，每当传递到敏感接收器的变量被污染时，就会激活误报预测器以收集属性向量，从而创建一个实例，并将该实例分类为误报或真正的漏洞。 在最后一种情况下，代码校正器被触发以准备代码的校正。 代码仅在过程结束时更新并存储在文件中，此时分析完成，并且所有必须进行的更正都是已知的。

### 9.3 结论

本文介绍了一种在 Web 应用程序中查找和纠正漏洞的方法，以及一种实现 PHP 程序和输入验证漏洞方法的工具。该方法和工具结合使用两种技术来搜索漏洞：静态源代码分析和数据挖掘。数据挖掘用于使用前 3 个机器学习分类器来识别误报，并使用归纳规则分类器来证明它们的存在。在对几个备选方案进行彻底比较后，选择了所有分类器。需要注意的是，这种检测技术的组合不能提供完全正确的结果。静态分析问题是不可判定的，借助数据挖掘无法规避这种不可判定性，只能提供概率结果。该工具通过插入修复程序来更正代码，即清理和验证功能。测试用于验证修复是否真正消除了漏洞并且不会损害应用程序的（正确）行为。该工具曾尝试使用带有故意插入漏洞的合成代码，以及大量开源 PHP 应用程序。它还与两个源代码分析工具进行了比较：Pixy 和 PhpMinerII。该评估表明，该工具可以检测和纠正其被编程处理的类的漏洞。它能够在 140 万行代码中找到 388 个漏洞。它的准确度和精确度比 PhpMinerII 高出大约 5%，比 Pixy 高出 45%。



## 10. **Detecting False Alarms from Automatic Static Analysis Tools: **How Far are We?

### 10.0 基本信息

Kang, Hong Jin, Khai Loong Aw, and David Lo. "Detecting False Alarms from Automatic Static Analysis Tools: How Far are We?." *arXiv preprint arXiv:2202.05982* (2022).

### 10.1 问题与现状

1. Findbugs 等自动静态分析工具 (ASAT) 的误报率很高。 产生的大量误报构成了采用的障碍。

2. 我们发现，一些研究使用了导致数据泄漏和数据重复的实验程序，这些都是具有重大影响的微妙问题。

3. 启发式产生的标签与人类预言不符。因此，如果在实践中采用，以前看到的这些技术的强大性能对其真实性能过于乐观。

4. 虽然静态分析的过度近似可能会导致错误警报，但错误警报不仅指分析错误或过度近似，还包括开发人员未采取行动的警告。 如果开发人员认为警告不代表错误或认为修复风险太大，他们可能不会对警告采取行动。

   ![image-20221007101144075](%E8%AE%BA%E6%96%87%E7%BB%BC%E8%BF%B0%EF%BC%886~10%EF%BC%89.assets/image-20221007101144075.png)

   ​									每个项目中与其 Findbugs 过滤器文件匹配的打开警告数。 如果警告被过滤，则表明项目的开发人员认为这是一个误报。

### 10.2 解决方案

1. 研究人员建议使用机器学习来消除误报，并仅向开发人员提供可操作的警告。 最先进的研究已经根据对文件、代码和警告的特征和历史计算的指标确定了一组“黄金特征”。 最近的研究表明，使用这些特征的机器学习非常有效，并且它们达到了几乎完美的性能。

2. 我们展示了确定真实标签的警告预言的局限性，这是一种将给定修订版中的警告与未来参考修订版进行比较的启发式方法。我们展示了参考修订的选择会影响警告分布。

3. 许多研究人员提出了修剪误报和识别可操作警告的技术，这些警告是开发人员将修复的警告。这些方法考虑了项目中 Findbugs 报告的警告的不同方面，包括有关源代码的因素、存储库历史记录、文件特征以及有关项目中 Findbugs 警告修复的历史数据。Wang等人完成了对文献中提出的特征的系统评估，并确定了 23 个“黄金特征”，这是检测可操作 Findbugs 警告的最重要特征。一个完美的预测器具有 100% 的召回率、精度和 AUC，这表明使用黄金特征的机器学习技术几乎是完美的。

4. 封闭警告启发式。 图 1 显示了构建和标记真实数据集的过程。为了评估检测误报的方法，收集了 Findbugs 警告的数据集。 虽然一些研究人员通过手动标记单个修订中的警告来构建标记数据集，但其他研究人员通过自动地面实况数据收集过程收集数据集。 收集测试修订和至少一个培训修订的数据，按时间顺序设置在测试修订之前。 这模拟了该工具的实际使用情况，其中对项目历史进行了培训，然后在测试修订时使用。

   ![image-20221007095427552](%E8%AE%BA%E6%96%87%E7%BB%BC%E8%BF%B0%EF%BC%886~10%EF%BC%89.assets/image-20221007095427552.png)

   ​				图 1：数据集包含在训练和测试修订之前创建的警告。 每个警告的标签由封闭警告启发式确定； 如果在参考修订版处关闭警告并且文件尚未删除，							则它是可操作的。

### 10.3 结论

1. Wang等人对Golden Features的进一步研究表明，机器学习模型的选择对有效性缺乏影响。 他们认为线性 SVM 是最优的，因为它需要较低的训练成本。 相比之下，虽然深度学习方法达到了相似的有效性水平，但它的训练时间更长。 他们的分析表明，误报的检测本质上是一个简单的问题。 另一项研究表明，使用黄金特征，只需标记一小部分数据集即可训练有效的分类器。 
2. 尽管实现了出色的性能，但 Golden Features 存在与数据泄漏和数据重复相关的细微错误。 这强调了对实验结果进行更深入分析的重要性，定量和定性分析都是必不可少的。 我们呼吁需要更多的复制研究，因为这样的工作可以突出未来工作的机遇和挑战。 我们的工作再次强调了将现有技术和新提出的技术与简单基线进行比较的必要性。
3. 用于生成标签的封闭警告启发式允许构建大型数据集，但不足以构建基准。 我们的工作揭示了封闭警告启发式的局限性，表明它可能不够准确； 警告可能会被偶然关闭，而可操作的警告可能会在关闭之前保持打开数年。
4. 我们的分析表明，在开发人员检查静态分析警告之前可能会有延迟。 与此相关，Zheng 等人发现，Bugzilla 中许多问题的状态可能只有在大延迟之后才会改变。 这些延迟对用于从历史数据自动推断标签的启发式算法有影响（在我们的例子中：如果警告是可操作的）。
5. 我们的研究强调了对警告预言进行更深入研究以确定真实标签的必要性。通过更改参考版本，可以得出关于黄金特征性能的不同结论。此外，oracle 会产生人工注释者和使用静态分析工具的项目开发人员可能不同意的标签。我们的实验表明，Golden Features SVM 在更清洁的数据上提高了性能。
6. 我们的研究表明了未来工作的机遇和挑战。它强调了社区需要努力建立一个大而可靠的基准，并将新提出的方法与稻草人基线进行比较。