## 1.DroidAlarm: An All-sided Static Analysis Tool for Android Privilege-escalation Malware

### 1.1摘要

由于智能手机存储了各种敏感的隐私信息，包括信用卡等，因此大量的恶意软件都想篡改它们。作为最普遍的平台之一，安卓系统包含的敏感资源只能通过相应的API访问，而且只有当用户拥有安卓系统权限模型中的授权权限时，才能调用这些API。然而，一种名为特权升级攻击的新型威胁可能会绕过这种看门狗。它表现为权限较少的应用程序可以通过权限较高的应用程序的公共接口访问敏感资源，这对恶意软件来说特别有用，可以通过将敏感功能分散到多个程序中来隐藏它们。我们在安卓恶意软件基因组项目的样本上探索特权升级的恶意软件进化技术。他们对VirusTotal提供的一套强大的反病毒工具表现出极大的有效性。与改造前的平均61%的检测率相比，检测率呈现出不同的明显下降。为了征服这种威胁模式，我们开发了一个名为DroidAlarm的工具，通过对Android应用程序的静态分析，进行全谱分析，以识别潜在的能力泄漏，并提出具体的能力泄漏路径。而且我们还可以通过暴露其中的能力泄漏路径来对所有这些情况进行报警。

### 1.2基本信息

Zhongyang, Yibing, et al. "DroidAlarm: an all-sided static analysis tool for Android privilege-escalation malware." *Proceedings of the 8th ACM SIGSAC symposium on Information, computer and communications security*. 2013.

### 1.3问题与现状

1. 由于安卓应用程序市场的日益壮大，许多恶意软件越权窃取用户隐私，或是直接绕过权限授权机制获取敏感权限。
2. 动态方法侧重于调用图分析，IPC的调用链或定制的监控框架来解决部分或全部的攻击。然而，这些方法存在路径覆盖和输入有效性的问题。
3. 有一些静态技术来分析股票图像或应用程序中的攻击。然而，他们只关心中间件层的公共接口，而不包括内核层的其他形式的公共接口，包括文件系统。

### 1.4解决方案

1. 开发了一个自动静态分析器来报警这些情况，建立了三个特权升级的转化模型来解释基于不同功能的一个问题。为了对攻击进行报警，开发了DroidAlarm来执行自动静态分析过程。相关文件（即配置文件和可执行文件）被解析为敏感权限和公共接口，以揭示其能力的泄漏。与这些权限相对应的API调用将被定位。
2. 然后，基于有关这些API的合作方式，将检查现有的公共接口，并跟踪数据流以获得具体的能力泄漏路径，这将提高用户对潜在特权升级攻击的警惕。
3. 用DroidAlarm分析了来自Android Malware Genome Project 的49个知名恶意软件，它们已经涉及这个项目中的所有恶意软件模式。我们根据不同的功能将它们转化为特权升级的恶意软件。转化后，这些特权升级的恶意软件绕过了VirusTotal上的大多数防病毒工具。然而，我们仍然可以对所有这些情况进行报警。

### 1.5结果

首先，我们在VirusTotal上检查每个现有的恶意软件，其平均检测率为61%。发现三个恶意软件的泄漏路径，即AnserverBot、Bgserv和NickyBot。基于可转化的功能，我们选择FakePlayer、GPSSMSSpy、DroidDream和GamblerSMS来执行所有三个转化模型。与泄漏路径分析前67%的报警率相比，分析后的报警率为6%，假阳性案例的数量大大减少。

![结果](C:\Users\86178\AppData\Roaming\Typora\typora-user-images\image-20221011205554802.png)

我们发现网络套接字和文件系统的形式也被频繁使用。所以这两种形式不能被忽视。由于我们认识到所有通信渠道的公共接口，我们可以很容易地找到这些公共接口，并建立具体的路径来显示能力泄漏。

### 1.6结论

在本文中，我们展示了DroidAlarm，通过静态分析安卓恶意软件中的能力泄露来报警特权升级攻击。在49个恶意软件中，有3个被认为是暴露了能力泄漏。然后，我们在三个模型中用特权升级攻击技术改造一些恶意软件，以绕过VirusTotal上的传统检测。在每个变体上，检测率都有不同程度的下降。变体。然而，这些情况仍然可以触发我们的警报。

## 2.An Empirical Assessment on Merging and Repositioning of Static Analysis Alarms

### 2.1摘要

静态分析工具产生了大量的报警，而这些报警需要人工检查。在之前的工作中，提出了对报警的重新定位，将多个类似的报警合并在一起，用较少的报警来代替，并尽可能地根据报警产生的原因报告报警。其前提是，建议的报警合并和重新定位将减少人工检查的工作量。为了评估这个前提，本文对249名开发者进行了一项关于拟议的静态警报合并和重新定位的实证研究。该研究使用在C程序上产生的静态分析警报，其中的警报代表了现实生活中代码的合并与非合并以及重新定位与非重新定位的情况。开发人员被要求手动检查警报是否相对应产生的断言。此外，还做了两个空间认知测试来确定性能上的关系。实证评估结果表明，与预期相反，没有证据表明合并和重新定位警报会减少人工检查的工作量或提高检查的准确性（有时发现有负面影响）。认知能力方面的结果与理解力和警报检查准确性相关。

### 2.2基本信息

Mansoor, Niloofar, et al. "An Empirical Assessment on Merging and Repositioning of Static Analysis Alarms.

### 2.3问题与现状

静态分析工具有助于自动检测常见的编程错误，甚至证明安全关键系统中没有此类错误。然而，这些工具产生了大量的假结果。以前的研究报告指出，每一千行代码就有40个警报，35%到91%的警报是假阳性，将警报划分需要昂贵的人工检查。一些研究报告指出，大量的误报和人工检查警报所产生的费用是实践中工具使用不足的两个主要原因。

### 2.4解决方案

因为检查不同的报警可能需要不同的人力资源，我们考虑旨在减少人工检查工作量的技术，并评估它在多大程度上提高了用户在人工检查报警时的表现，所以我们考虑对报警进行重新评估。

警报的重新定位有两个目标：（1）将类似警报合并来减少警报的数量；（2）报告更接近其产生原因的警报，从而减少人力。在本文的其余部分，我们用合并报警来指代第一个重新定位的目标，用更接近的报告来指代第二个重新定位的目标。

同时，我们研究在何种程度上重新定位警报可以提高用户在手动检查警报时的表现。由于开发者的认知能力在他们解决问题的方式中起着作用，我们还试图调查认知任务和涉及人工检查警报的任务之间是否存在关系。

### 2.5结果

实证评估结果表明，与预期相反，我们没有发现足够的证据表明合并和重新定位警报可以减少人工检查的工作量或提高检查结果的准确性，有时它还会产生负面影响。仔细观察结果表明，研究结果是不确定的，需要进行更详细的研究来评估这一前提。

成果：

1. 进行了一项实证评估，以验证在评估警报的重新定位和合并时减少开发人员的努力这一假设。
2. 研究认知任务与手动检查重新定位和合并的警报之间的关系的调查。
3. 一个完整的可重复性的复制包。

### 2.6结论

本文研究了报警器的合并和重新定位对其检查时间和准确性的影响。从样本中发现，没有提供足够的证据表明报警器的重新定位和合并对报警器的检查时间和准确性有影响。然而，我们的分析表明，参与者的空间认知能力与他们的理解能力和准确性相关。

## 3.Effective Interactive Resolution of Static Analysis Alarms

### 3.1摘要

我们提出了一种解决静态分析警报的可交互方法。我们的方法通过用户互动，协同地将健全但不精确的分析与精确但不健全的启发式方法结合起来。在每个迭代中，它 解决一个优化问题，为用户找到一组问题，使预期回报达到最大。我们已经在一个工具中实现了我们的方法，即URSA，它能够为任何分析提供交互式警报解决方法 在陈述性逻辑编程语言Datalog中指定。我们证明了URSA的有效性 在最先进的静态数据流分析中的有效性，使用了一套8个Java程序，每个程序包括41-194KLOC。URSA能够消除每个基准中74%的错误警报，每个问题的平均回报率为12倍。此外，URSA通过提前提出产生高回报的问题，有效地安排了用户工作的优先次序。

### 3.2基本信息

Zhang, Xin, et al. "Effective interactive resolution of static analysis alarms." *Proceedings of the ACM on Programming Languages* 1.OOPSLA (2017): 1-30.

### 3.3概念

URSA：用于分析在Datalog中指定的针对Java程序的分析，使用Chord 作为Java分析框架，使用bddbddb作为Datalog求解器，使用Gurobi作为ILP求解器。

### 3.4问题与现状

自动化的静态分析做了一些近似的分析然而，它们在实践中导致了许多错误的警报，这反过来又给分析的用户带来了沉重的负担。

一个常见的减少误报的实用方法包括应用启发式方法来抑制其根本原因。例如，这种启发式方法可能会忽略某个可能导致高误报率的代码结构，使分析结果不健全。

(a) 静态分析是健全的，对基础事实不精确，并且快速。

(b) 启发式分析是不健全的，但对基础真理来说是精确的，而且速度快；以及 

(c) 神谕法与地面真相一致，但速度很慢。

### 3.5解决方案

在本文中，我们提出了一种新的方法，通过用户互动，向用户提出问题。如果用户确认了这些问题，启发式方法才会在用户知情的情况下被用于消除错误警报。

然而，为了有效，综合方法必须完成两个关键目标：概括化和优先化。我们将分别描述这些目标以及我们如何实现它们。

- 概括性。与被消除的错误警报的数量相比，我们的方法向用户提出的问题的数量应该小得多。
- 确定优先次序。按照回报率递减的顺序提出问题，允许用户在回报率递减时停止回答问题。迭代过程允许将用户对过去问题的回答纳入到对未来问题的更好选择中，从而进一步放大了用户努力的减少。

将问题简化为一连串的整数线性编程（ILP）实例。每个ILP实例对分析事实之间的依赖关系进行编码，并权衡询问不同的根本原因集的收益和成本。然后解决了一连串的ILP实例，在收益成本比的上限和下限之间进行二进制搜索。

我们在一个叫URSA的工具中实现了我们的方法。

### 3.6结果

URSA在每个基准中消除了74%的错误警报，每个问题的平均回报率为12倍。此外，URSA有效地对具有高回报的问题进行优先排序。此外，根据从40名Java程序员那里收集的数据，我们观察到，解决根本原因的平均时间只有解决警报的一半。这些结果共同表明，我们的方法实现了对用户工作的显著减少。

迭代1。URSA选择{shared(47)}作为最佳根集，因为它的期望报酬率为5，是所有根集中最高的。其他根集最终的期望报酬率较低。

迭代2。在这个迭代中，我们有两个最佳根集的候选者。{虽然解决（shared(46)}有望消除{race(46, 57), race(46, 71), race(46,72)}，但解决{shared(48)}只能消除{race(48, 74)}。

迭代3。在这个迭代中，只有一个根集{shared(48)}，它的预期报酬为1。

下图是显示每个迭代中所问问题与解决的错误警告的图表。

![image-20221013010136722](C:\Users\86178\AppData\Roaming\Typora\typora-user-images\image-20221013010136722.png)

### 3.7结论

总之，URSA通过只问两个（或三个）问题，以合理的方式解决了9个错误警报中的8个（或9个）。此外，它在早期迭代中优先考虑具有高回报率的问题。

## 4.Phoenix: Automated Data-Driven Synthesis of Repairs for Static Analysis Violations

### 4.1摘要

传统的自动程序修复（APR）工具依赖于测试套件作为修复规范。但是，即使有测试套件，其质量也不尽如人意，限制了基于测试套件的修复的性能和可行性。另一方面，基于静态分析的错误查找工具在工业界被越来越多地采用，但仍然面临挑战，因为报告的违规行为被认为 "不容易操作"。我们提出了一个新的解决方案，通过从实例中学习自动生成高质量的静态分析违规补丁的技术，解决了这两个挑战。我们的方法将静态分析器作为一个数据库，不需要测试套件。我们在一个名为PHOENIX的系统中实现了我们的解决方案，该系统实现了一个完全自动化的管道，"从野外挖掘和清理静态分析违规补丁，在新的特定领域语言（DSL）中学习通用的可执行修复策略，然后从它们中实例化新的未见过的违规修复。使用PHOENIX，我们从517个Github项目中挖掘了5389个独特的违规行为和补丁的语料库。在这个语料库的交叉验证研究中，PHOENIX成功地产生了4596个错误修复，召回率为85%，精确度为54%。当应用于另外5个Github项目的最新修订版时，PHOENTX产生了94个对以前未知错误的正确补丁，其中19个已经被开发团队接受并合并了。据我们所知，这是迄今为止任何自动补丁生成技术在大规模真实世界系统中的最大应用。

### 4.2基本信息

Bavishi, Rohan, Hiroaki Yoshida, and Mukul R. Prasad. "Phoenix: Automated data-driven synthesis of repairs for static analysis violations." *Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering*. 2019.

### 4.3问题与现状

软件调试和修补耗时耗力，需要自动程序修复（APR）。事实上，使用测试套件的APR产生了大量的不正确的补丁。最先进的APR技术在公开的缺陷数据集中正确修复了不到10%的缺陷，这些限制对基于测试服的APR技术的实际应用提出了重大挑战。

一个值得注意的相关趋势是在开发实践中越来越多地部署基于静态分析的错误查找工具。然而，报告的错误仍然需要人工调查、诊断和修复。

### 4.4解决方案

- 提出了一种基于学习的静态程序修复方法，它由两个关键因素组成。(1) 它使用一个现成的静态分析器，作为一个数据库，来识别潜在的 "bug"，并证明补丁是可行修复；(2) 它从代码挖掘出来的真实补丁中学习修复策略。这消除了对测试套件的依赖，同时利用了现在广泛使用的静态分析器。
- 使用了一个专门起草的DSL，将策略描述为程序，并使用合成算法来生成程序。它把每个修复看作是由一个根源产生的相关编辑的集合，将这个根源确定为程序的抽象语法树（AST）中的一个主要节点，并使用句法和语义参考的组合来描述。

### 4.5结果

1.在5389个补丁的数据库中进行了一个项目级的、留一漏万的交叉验证实验。

![image-20221014113247955](C:\Users\86178\AppData\Roaming\Typora\typora-user-images\image-20221014113247955.png)

结果见上图。PHOENIX达到了85%的召回率，表明它能够跨项目进行概括。

2.用PHOENDX来修复五个大型的、流行的开源Java项目上公开的FindBugs违规，即Apache Camel、Flink、Dubbo、Spring-Boot和Presto-DB。

![image-20221014113715299](C:\Users\86178\AppData\Roaming\Typora\typora-user-images\image-20221014113715299.png)

召回率为84%，表明精度为80%。这些结果表明，PHOEND学习了有效的策略，能够在野外修复未见过的违规行为。

3.我们重复了对PHOENIX-BASELINE的交叉验证研究，发现其召回率为72%，适度低于PHOENIX的85%。我们对PHOENIX和PHOENIX-BASELINE在两组各50个补丁上手动计算精度。第一组(COMPLEX)是从数据库中的10个违规类型中各抽出5个补丁组成的，我们认为这些类型涉及的编辑数量最多。第二组（SIMPLE）是从其余类型中抽出50个补丁构建的。

![image-20221014121654597](C:\Users\86178\AppData\Roaming\Typora\typora-user-images\image-20221014121654597.png)

与PHOENIX相比，PHOENIX-BASELINE在复杂的情况下表现出明显较低的精度。

### 4.6结论

使用PHOENIX，我们从517个GitHub项目中挖掘了一个5389个独特补丁的语料库。在对该语料库的交叉验证研究中，PHOENIX成功地产生了4382个错误修复，召回率为85%，精确度为54%。当应用于另外5个GitHub项目的最新修订版时，PHOENIX对以前未知的错误产生了94个正确的补丁，其中19个已经被开发团队接受并合并了。

## 5.AVATAR: Fixing Semantic Bugs with Fix Patterns of Static Analysis Violations

### 5.1摘要

基于修复模式的补丁生成是自动程序修复（APR）中很有前途的方向。然而，基于模式的APR系统的性能取决于从开发历史的修复变化中挖掘出来的修复成分。不幸的是，在存储库中收集一套可靠的错误修复是有难度的。在本文中，我们建议研究在APR场景中利用静态错误检测工具解决违规问题的代码修改的可能性。为此，我们建立了AVATAR APR系统，该系统利用静态分析违规行为的修复模式作为生成补丁的成分。通过对基准的评估，我们发现，假设故障的完美定位，AVATAR可以生成正确的补丁来修复34139个错误。我们进一步发现，AVATAR产生的性能指标与文献中与之密切相关的方法相当。虽然AVATAR超过了许多最先进的基于模式的APR系统，但它主要是对当前方法的补充。总的来说，我们的研究强调了静态错误查找工具的相关性，它是解决功能测试用例中发现的代码缺陷的修复成分的重要贡献者。

### 5.2基本信息

Liu, Kui, et al. "Avatar: Fixing semantic bugs with fix patterns of static analysis violations." *2019 IEEE 26th International Conference on Software Analysis, Evolution and Reengineering (SANER)*. IEEE, 2019.

### 5.3问题与现状

目前，自动程序修复（APR）的发展势头已经导致了文献中各种方法的发展。不幸的是，鉴于测试套件可能是不完整的，典型的APR系统很容易产生无意义的补丁，这些补丁可能违反了预期的程序行为，或者只是引入了测试套件没有涵盖的其他缺陷。Smith等人最近的一项研究彻底调查了这个问题，并发现过拟合的补丁实际上很常见：这些补丁可以通过所有可用的测试案例，但实际上并不正确。

已经有了挖掘修复模式的方法，并探索了实现修复成分的多样性和可靠性的挑战。Long等人只依靠三种简单的错误类型，而Koyuncu等人则专注于错误跟踪系统和源代码管理系统之间的错误链接，以识别可能的错误修复。不幸的是，前一种方法不能找到解决各种bug的模式，而后者可能包括与bug修复无关的模式，因为开发人员的变化不是原子性的；因此，提取有用和可靠的模式专注于修复变化是具有挑战性的。

### 5.4解决方案

为了解决APR中补丁正确性的问题，文献中正在研究改进补丁生成过程，以减少生成无意义的补丁的概率。

AVATAR由自动程序修复的四个主要步骤组成。

A. 故障定位 

B. 修复模式匹配 

C. 补丁生成

D. 补丁验证

### 5.5结果

在Defects4J[61]上对AVATAR进行评估，它被最先进的针对Java程序的APR系统广泛使用。下图总结了Defects4J的1.2.0版本中的错误和测试案例的数量统计。

![image-20221013014300535](C:\Users\86178\AppData\Roaming\Typora\typora-user-images\image-20221013014300535.png)

"Bugs"、"kLoC "和 "Tests"分别表示错误的数量、以KLoC为单位的程序大小（即数千行代码）和测试的数量，以及每个主题的测试用例的数量。每个课题的项目Mockito的KLoC和测试用例的总数量在Defects4J的论文中没有说明。

下图是被AVATAR修复的但未被其他APR工具修复的bug，可以看出，AVATAR 相较于其他APR工具的优越性。

![image-20221013014953775](C:\Users\86178\AppData\Roaming\Typora\typora-user-images\image-20221013014953775.png)

### 5.6结论

我们建议依靠开发者的补丁来解决静态分析错误。这样的补丁是简洁而精确的，它们的功效（在消除错误方面）由静态检测器系统地评估。AVATA利用了来自静态分析违规补丁的修复成分，经验表明，它在修复有语义错误的程序方面确实有效。AVATAR在修复文献中尚未被任何APR系统修复的一些Defects4J错误时，表现优于一些最先进的方法，并对其他方法进行了补充。
